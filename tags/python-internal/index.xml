<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python-internal on Chaosmatrix</title>
    <link>https://chaosmatrix.github.io/tags/python-internal/</link>
    <description>Recent content in python-internal on Chaosmatrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Copyright chaosmatrix</copyright>
    <lastBuildDate>Fri, 09 Sep 2022 21:05:18 +0800</lastBuildDate><atom:link href="https://chaosmatrix.github.io/tags/python-internal/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[python internal] Implementation of Type Dict</title>
      <link>https://chaosmatrix.github.io/blog/python_internal_implementation_of_type_dict/</link>
      <pubDate>Fri, 09 Sep 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/python_internal_implementation_of_type_dict/</guid>
      <description>Abstract using char[] store data, using Open Addressing handle hash collision hash table will be expanded only there are no valid solt or hash table isn&amp;rsquo;t combined (dict always combined ?) deleting item won&amp;rsquo;t decrease memory usage, only update matching solt with value DKIX_DUMMY during resizing, all old data will be copy into new hash table, then free old hash table memory usage in python3, keys() and values() create view object, not list object (python2) Metrics Operation Average Case Amortized Worst Case copy O(n) O(n) k in d O(1) O(n) get O(1) O(n) set O(1) O(n) delete O(1) O(n) iteration O(n) O(n) Source Code background:</description>
    </item>
    
    <item>
      <title>[python internal] From Python to Bytecode until C</title>
      <link>https://chaosmatrix.github.io/blog/python_internal_from_python_to_bytecode_until_c/</link>
      <pubDate>Sat, 03 Sep 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/python_internal_from_python_to_bytecode_until_c/</guid>
      <description>Abstract Use module dis to get the minimize assembly code. Found the entry from Python/ceval.c with the bytecode that disassembled before. Now the door is open and the road is at your feet. Python -&amp;gt; Bytecode -&amp;gt; C Vesion: Python-3.10.6
1. Example - Python &amp;gt;&amp;gt;&amp;gt; def f(): ... d = {} ... d[1] = 1 ... 2. Python -&amp;gt; Bytecode &amp;gt;&amp;gt;&amp;gt; import dis &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; def f(): ... d = {} .</description>
    </item>
    
    <item>
      <title>[python internal] Implementation of Type List</title>
      <link>https://chaosmatrix.github.io/blog/python_internal_implementation_of_type_list/</link>
      <pubDate>Sun, 28 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/python_internal_implementation_of_type_list/</guid>
      <description>Abstract The only way to shrink list without delete element is making a copy of the old one, like l = l[:len(l)] or a = l.copy() Large list might has lots of allocated but unused space Deleting element has an ability of shrinking list Metrics Operation Average Case Amortized Worst Case Increase Space Inplace Resize copy O(n) O(n) O(n) N I append O(1) O(1) O(1) Y I|- clear O(n) O(n) - Y D count O(n) O(n) - N - extend O(k) O(k) O(k) Y I|- index O(n) O(n) - N - insert O(n) O(n) O(1) Y I|- pop O(n) O(n) Y D|- remove O(n) O(n) Y D|- reverse O(n) O(n) Y - sort O(n log n) O(n log n) - Y - __add__ O(n + k) O(n + k) O(n + k) N I __iadd__ O(k) O(k) O(k) Y I- __mul__ O(n*k) O(n*k) O（n*k) N I __imul__ O(n*(k-1)) O(n*(k-1)) O(n*(k-1)) Y I- Comment:</description>
    </item>
    
    <item>
      <title>[python-internal] Binary and In-place Operation</title>
      <link>https://chaosmatrix.github.io/blog/python_internal_binary_and_in-place_operation/</link>
      <pubDate>Sun, 21 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/python_internal_binary_and_in-place_operation/</guid>
      <description>Abstract Use of a compound operator that will be compiled into INPLACE_* bytecode instruction at the end may result in a bug that is difficult to debug. Why In-place operation design like this ? to make code more &amp;ldquo;pythonic&amp;rdquo; and increase performance in some case (avoid allocating new memory areas. this can be verified by using sys.getsizeof() to get object&amp;rsquo;s current memory allocated and id() to checking whether object&amp;rsquo;s pointer change or not) What As python coder, binary operation is the code using arithmetic operator like + , - , * , / , % .</description>
    </item>
    
  </channel>
</rss>
