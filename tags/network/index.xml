<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>network on Chaosmatrix</title>
    <link>https://chaosmatrix.github.io/tags/network/</link>
    <description>Recent content in network on Chaosmatrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© Copyright chaosmatrix</copyright>
    <lastBuildDate>Mon, 08 Aug 2022 21:05:18 +0800</lastBuildDate><atom:link href="https://chaosmatrix.github.io/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DNS Should I Use DNSSEC</title>
      <link>https://chaosmatrix.github.io/blog/dns_should_i_use_dnssec/</link>
      <pubDate>Mon, 08 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/dns_should_i_use_dnssec/</guid>
      <description>Abstract WARNING DNSSEC can only works as expected when the resolver ensure the zone and the upstream nameserver support DNSSEC WARNING less 50% top-1m website/domain enable DNSSEC, most zone owned by google/amazon/microsoft &amp;hellip; not support DNSSEC DNSSEC can only make sure the data that the resolver fetching is provided by the zone&amp;rsquo;s owner (require resolver verify the signature) DNSSEC can detect (not prevent) dns hijacking only when resolver/client verify the signature As Owner/Server: Assess only use it when you pretty sure you need it, and can&amp;rsquo;t replace with another way, and should base on the report that the use of DNSSEC validation for your customer&amp;rsquo;s ISPs public resolvers use E2EE protocol to protect the communication between client and server instead of ensuring client get the right server&amp;rsquo;s address try to use DNS-Over-HTTPS/DNS-Over-QUIC to prevent dns hijacking if you can control how client resolve domain, for example desktop/mobile app As Resolver: Recommend But Not Forcing Recursive Resolver: Recommend, try to add additional security check, like credit score of ip address to detect dns hijacking Forward Resolver: Not Recommend, try to communicate with upstream nameserver with E2EE protocol, use DNSSEC only for the zone that pretty sure has full DNSSEC support and sensitive zone (like bank, shop) Basic DNSSEC strengthens authentication in DNS using digital signatures based on public key cryptography.</description>
    </item>
    
    <item>
      <title>UDP Server Listen On 0.0.0.0</title>
      <link>https://chaosmatrix.github.io/blog/udp_server_listen_on_0.0.0.0/</link>
      <pubDate>Mon, 01 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/udp_server_listen_on_0.0.0.0/</guid>
      <description>Basic UDP is connectionless protocol, it won&amp;rsquo;t create new socket for any incoming datagrams, so, function like LocalAddr() will return incorrect destination address that associated with incoming datagrams, and response datagram will be routed base on system&amp;rsquo;s default routing rule, which might not match client&amp;rsquo;s 5-tuple.
Example:
# basic 1. server: * has two address: 10.1.2.2(primary) and 10.1.2.3(secondary) * default route is 10.1.2.2 (default outgoing address) 2. client: * has one address: 10.</description>
    </item>
    
    <item>
      <title>Detect Half Closed Connection</title>
      <link>https://chaosmatrix.github.io/blog/detect_half_closed_connection/</link>
      <pubDate>Wed, 27 Jul 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/detect_half_closed_connection/</guid>
      <description>$common$ read 1-byte with deadline depend on program language or platform implementation, some use read 0-byte
WARNING: you should only use this way when you ensure there&#39;s no unread value data
// Golang, read 0-byte, always return nil // https://github.com/golang/go/issues/10940#issuecomment-245773886 func checkConn(conn net.Conn, timeout time.Duration) error { buf := make([]byte, 1) err := conn.SetReadDeadline(time.Now().Add(timeout)) if err != nil { return err } n, err := conn.Read(buf) if err == io.EOF { return err } if n !</description>
    </item>
    
  </channel>
</rss>
