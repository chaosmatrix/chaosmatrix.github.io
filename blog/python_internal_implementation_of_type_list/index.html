<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>[python] Internal Implementation of Type List - Chaosmatrix</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="[python] Internal Implementation of Type List">
<meta itemprop="description" content="Abstract The only way to shrink list without delete element is making a copy of the old one, like l = l[:len(l)] or a = l.copy() Large list might has lots of allocated but unused space Deleting element has an ability of shrinking list Metrics Operation Average Case Amortized Worst Case Increase Space Inplace Resize copy O(n) O(n) O(n) N I append O(1) O(1) O(1) Y I|- clear O(n) O(n) - Y D count O(n) O(n) - N - extend O(k) O(k) O(k) Y I|- index O(n) O(n) - N - insert O(n) O(n) O(1) Y I|- pop O(n) O(n) Y D|- remove O(n) O(n) Y D|- reverse O(n) O(n) Y - sort O(n log n) O(n log n) - Y - __add__ O(n &#43; k) O(n &#43; k) O(n &#43; k) N I __iadd__ O(k) O(k) O(k) Y I- __mul__ O(n*k) O(n*k) O（n*k) N I __imul__ O(n*(k-1)) O(n*(k-1)) O(n*(k-1)) Y I- Comment:"><meta itemprop="datePublished" content="2022-08-28T21:05:18+08:00" />
<meta itemprop="dateModified" content="2022-08-28T21:05:18+08:00" />
<meta itemprop="wordCount" content="1613">
<meta itemprop="keywords" content="python," /><meta property="og:title" content="[python] Internal Implementation of Type List" />
<meta property="og:description" content="Abstract The only way to shrink list without delete element is making a copy of the old one, like l = l[:len(l)] or a = l.copy() Large list might has lots of allocated but unused space Deleting element has an ability of shrinking list Metrics Operation Average Case Amortized Worst Case Increase Space Inplace Resize copy O(n) O(n) O(n) N I append O(1) O(1) O(1) Y I|- clear O(n) O(n) - Y D count O(n) O(n) - N - extend O(k) O(k) O(k) Y I|- index O(n) O(n) - N - insert O(n) O(n) O(1) Y I|- pop O(n) O(n) Y D|- remove O(n) O(n) Y D|- reverse O(n) O(n) Y - sort O(n log n) O(n log n) - Y - __add__ O(n &#43; k) O(n &#43; k) O(n &#43; k) N I __iadd__ O(k) O(k) O(k) Y I- __mul__ O(n*k) O(n*k) O（n*k) N I __imul__ O(n*(k-1)) O(n*(k-1)) O(n*(k-1)) Y I- Comment:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chaosmatrix.github.io/blog/python_internal_implementation_of_type_list/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-08-28T21:05:18+08:00" />
<meta property="article:modified_time" content="2022-08-28T21:05:18+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[python] Internal Implementation of Type List"/>
<meta name="twitter:description" content="Abstract The only way to shrink list without delete element is making a copy of the old one, like l = l[:len(l)] or a = l.copy() Large list might has lots of allocated but unused space Deleting element has an ability of shrinking list Metrics Operation Average Case Amortized Worst Case Increase Space Inplace Resize copy O(n) O(n) O(n) N I append O(1) O(1) O(1) Y I|- clear O(n) O(n) - Y D count O(n) O(n) - N - extend O(k) O(k) O(k) Y I|- index O(n) O(n) - N - insert O(n) O(n) O(1) Y I|- pop O(n) O(n) Y D|- remove O(n) O(n) Y D|- reverse O(n) O(n) Y - sort O(n log n) O(n log n) - Y - __add__ O(n &#43; k) O(n &#43; k) O(n &#43; k) N I __iadd__ O(k) O(k) O(k) Y I- __mul__ O(n*k) O(n*k) O（n*k) N I __imul__ O(n*(k-1)) O(n*(k-1)) O(n*(k-1)) Y I- Comment:"/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://chaosmatrix.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://chaosmatrix.github.io/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://chaosmatrix.github.io/css/dark.css" />

	<script src="https://chaosmatrix.github.io/js/feather.min.js"></script>
	
		<script src="https://chaosmatrix.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://chaosmatrix.github.io/">
				<img src="https://avatars.githubusercontent.com/u/37551759?v=4" alt="Chaosmatrix" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://chaosmatrix.github.io/">Chaosmatrix</a></h1>
	<div class="site-description"><p>Thoughts come and go, words stay eternal</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/chaosmatrix" title="Github"><i data-feather="github"></i></a></li><li><a href="#" class="scheme-toggle" id="scheme-toggle"></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/blog">Blog</a>
			</li>
			
			<li>
				<a href="/wasm">Wasm</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">28</span>
							<span class="rest">Aug 2022</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">[python] Internal Implementation of Type List</h1>
				</div>
			</div>
					
			<div class="markdown">
				<h2 id="abstract">Abstract</h2>
<ol>
<li>The only way to shrink list without delete element is making a copy of the old one, like <strong>l = l[:len(l)]</strong> or <strong>a = l.copy()</strong></li>
<li>Large list might has lots of allocated but unused space</li>
<li>Deleting element has an ability of shrinking list</li>
</ol>
<h2 id="metrics">Metrics</h2>
<table>
<thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>Average Case</strong></th>
<th><strong><a href="http://en.wikipedia.org/wiki/Amortized_analysis">Amortized Worst Case</a></strong></th>
<th>Increase Space</th>
<th>Inplace</th>
<th>Resize</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>N</td>
<td>I</td>
</tr>
<tr>
<td>append</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Y</td>
<td>I|-</td>
</tr>
<tr>
<td>clear</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>Y</td>
<td>D</td>
</tr>
<tr>
<td>count</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>N</td>
<td>-</td>
</tr>
<tr>
<td>extend</td>
<td>O(k)</td>
<td>O(k)</td>
<td>O(k)</td>
<td>Y</td>
<td>I|-</td>
</tr>
<tr>
<td>index</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>N</td>
<td>-</td>
</tr>
<tr>
<td>insert</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>Y</td>
<td>I|-</td>
</tr>
<tr>
<td>pop</td>
<td>O(n)</td>
<td>O(n)</td>
<td></td>
<td>Y</td>
<td>D|-</td>
</tr>
<tr>
<td>remove</td>
<td>O(n)</td>
<td>O(n)</td>
<td></td>
<td>Y</td>
<td>D|-</td>
</tr>
<tr>
<td>reverse</td>
<td>O(n)</td>
<td>O(n)</td>
<td></td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>sort</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>-</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>N</td>
<td>I</td>
</tr>
<tr>
<td><code>__iadd__</code></td>
<td>O(k)</td>
<td>O(k)</td>
<td>O(k)</td>
<td>Y</td>
<td>I-</td>
</tr>
<tr>
<td><code>__mul__</code></td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O（n*k)</td>
<td>N</td>
<td>I</td>
</tr>
<tr>
<td><code>__imul__</code></td>
<td>O(n*(k-1))</td>
<td>O(n*(k-1))</td>
<td>O(n*(k-1))</td>
<td>Y</td>
<td>I-</td>
</tr>
</tbody>
</table>
<p>Comment:</p>
<ol>
<li>Resize:
<ul>
<li>I: realloc memory (allocate more memory)</li>
<li>-: not allocated memory</li>
<li>D: deallocated memory</li>
<li>N: malloc memory ( new create)</li>
</ul>
</li>
<li>Increase Space: the number of elements that added after call the function, not the total number, and not the memory size
<ul>
<li><strong>pop(k)</strong> / <strong>remove(x)</strong>: use <strong>memmove</strong> and <strong>free</strong> delete element, <strong>memmove</strong> will copy  <strong>l[k+1:]</strong> to temporary memory area and then copy into <strong>l[k:]</strong></li>
<li><strong>pop(k)</strong>: <strong><code>O(1)</code></strong> ?, it use <strong>memmove</strong> to insert / delete element when k not the last index in list, performance depend on <strong>memmove</strong></li>
<li><strong>remove(x)</strong>: <strong>O(n)</strong>, need to found the index of x in list first, then using <strong>memmove</strong> to delete element</li>
<li><strong>clear()</strong>: <strong>O(n)</strong>, need to traverse all objects then free every one, <strong>release memory immediately</strong></li>
</ul>
</li>
<li>Get Memory Usage
<ol>
<li><strong>sys.getsizeof(object)</strong>: object&rsquo;s size + garbage collector overhead (notmally, 16)</li>
<li><strong>object.__sizeof__()</strong>: object&rsquo;s size</li>
</ol>
</li>
</ol>
<h2 id="source-code">Source Code</h2>
<p>background:</p>
<ol>
<li>python-3.10.6</li>
</ol>
<h3 id="shrinking-list">Shrinking list</h3>
<hr>
<p><strong>shrinking list by deleting elements:</strong></p>
<ol>
<li>function <code>remove(x)</code> and <code>pop(k)</code> , when i == 0, it has bad performance, and it&rsquo;s better to create new one</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#008000">// Python-3.10.6/Objects/listobject.c
</span></span></span><span style="display:flex;"><span><span style="color:#008000">//
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// algorithm about how list resize, include expansion and shrink
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#2b91af">int</span>
</span></span><span style="display:flex;"><span>list_resize(PyListObject *self, Py_ssize_t newsize)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; 1)) {
</span></span><span style="display:flex;"><span>        assert(self-&gt;ob_item != NULL || newsize == 0);
</span></span><span style="display:flex;"><span>        Py_SET_SIZE(self, newsize);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">/* This over-allocates proportional to the list size, making room
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * for additional growth.  The over-allocation is mild, but is
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * enough to give linear-time amortized behavior over a long
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * sequence of appends() in the presence of a poorly-performing
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * system realloc().
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * Add padding to make the allocated size multiple of 4.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * The growth pattern is:  0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ...
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * Note: new_allocated won&#39;t overflow because the largest possible value
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     *       is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     */</span>
</span></span><span style="display:flex;"><span>    new_allocated = ((size_t)newsize + (newsize &gt;&gt; 3) + 6) &amp; ~(size_t)3;
</span></span><span style="display:flex;"><span>    <span style="color:#008000">/* Do not overallocate if the new size is closer to overallocated size
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * than to the old size.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (newsize - Py_SIZE(self) &gt; (Py_ssize_t)(new_allocated - newsize))
</span></span><span style="display:flex;"><span>        new_allocated = ((size_t)newsize + 3) &amp; ~(size_t)3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (newsize == 0)
</span></span><span style="display:flex;"><span>        new_allocated = 0;
</span></span><span style="display:flex;"><span>    num_allocated_bytes = new_allocated * <span style="color:#00f">sizeof</span>(PyObject *);
</span></span><span style="display:flex;"><span>    items = (PyObject **)PyMem_Realloc(self-&gt;ob_item, num_allocated_bytes);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (items == NULL) {
</span></span><span style="display:flex;"><span>        PyErr_NoMemory();
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> -1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    self-&gt;ob_item = items;
</span></span><span style="display:flex;"><span>    Py_SET_SIZE(self, newsize);
</span></span><span style="display:flex;"><span>    self-&gt;allocated = new_allocated;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p><strong>Notice:</strong></p>
<ol>
<li><strong>list.remove(x)</strong> / <strong>list.pop(k)</strong> internal implementation</li>
<li><strong>l[i:j] = a</strong> (a is list object) internal implementation</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#008000">// Python-3.10.6/Objects/listobject.c
</span></span></span><span style="display:flex;"><span><span style="color:#008000">//
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#2b91af">int</span>
</span></span><span style="display:flex;"><span>list_ass_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    PyObject *recycle_on_stack[8];
</span></span><span style="display:flex;"><span>    PyObject **recycle = recycle_on_stack; <span style="color:#008000">/* will allocate more if needed */</span>
</span></span><span style="display:flex;"><span>    PyObject **item;
</span></span><span style="display:flex;"><span>    PyObject **vitem = NULL;
</span></span><span style="display:flex;"><span>    PyObject *v_as_SF = NULL; <span style="color:#008000">/* PySequence_Fast(v) */</span>
</span></span><span style="display:flex;"><span>    Py_ssize_t n; <span style="color:#008000">/* # of elements in replacement list */</span>
</span></span><span style="display:flex;"><span>    Py_ssize_t norig; <span style="color:#008000">/* # of elements in list getting replaced */</span>
</span></span><span style="display:flex;"><span>    Py_ssize_t d; <span style="color:#008000">/* Change in size */</span>
</span></span><span style="display:flex;"><span>    Py_ssize_t k;
</span></span><span style="display:flex;"><span>    size_t s;
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">int</span> result = -1;            <span style="color:#008000">/* guilty until proved innocent */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">#define b ((PyListObject *)v)
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>    <span style="color:#00f">if</span> (v == NULL)
</span></span><span style="display:flex;"><span>        n = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (a == b) {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">/* Special case &#34;a[i:j] = a&#34; -- copy b first */</span>
</span></span><span style="display:flex;"><span>            v = list_slice(b, 0, Py_SIZE(b));
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (v == NULL)
</span></span><span style="display:flex;"><span>                <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>            result = list_ass_slice(a, ilow, ihigh, v);
</span></span><span style="display:flex;"><span>            Py_DECREF(v);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v_as_SF = PySequence_Fast(v, <span style="color:#a31515">&#34;can only assign an iterable&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span>(v_as_SF == NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> Error;
</span></span><span style="display:flex;"><span>        n = PySequence_Fast_GET_SIZE(v_as_SF);
</span></span><span style="display:flex;"><span>        vitem = PySequence_Fast_ITEMS(v_as_SF);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (ilow &lt; 0)
</span></span><span style="display:flex;"><span>        ilow = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ilow &gt; Py_SIZE(a))
</span></span><span style="display:flex;"><span>        ilow = Py_SIZE(a);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (ihigh &lt; ilow)
</span></span><span style="display:flex;"><span>        ihigh = ilow;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ihigh &gt; Py_SIZE(a))
</span></span><span style="display:flex;"><span>        ihigh = Py_SIZE(a);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    norig = ihigh - ilow;
</span></span><span style="display:flex;"><span>    assert(norig &gt;= 0);
</span></span><span style="display:flex;"><span>    d = n - norig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (Py_SIZE(a) + d == 0) {
</span></span><span style="display:flex;"><span>        Py_XDECREF(v_as_SF);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> _list_clear(a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    item = a-&gt;ob_item;
</span></span><span style="display:flex;"><span>    <span style="color:#008000">/* recycle the items that we are about to remove */</span>
</span></span><span style="display:flex;"><span>    s = norig * <span style="color:#00f">sizeof</span>(PyObject *);
</span></span><span style="display:flex;"><span>    <span style="color:#008000">/* If norig == 0, item might be NULL, in which case we may not memcpy from it. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (s) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (s &gt; <span style="color:#00f">sizeof</span>(recycle_on_stack)) {
</span></span><span style="display:flex;"><span>            recycle = (PyObject **)PyMem_Malloc(s);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (recycle == NULL) {
</span></span><span style="display:flex;"><span>                PyErr_NoMemory();
</span></span><span style="display:flex;"><span>                <span style="color:#00f">goto</span> Error;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        memcpy(recycle, &amp;item[ilow], s);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (d &lt; 0) { <span style="color:#008000">/* Delete -d items */</span>
</span></span><span style="display:flex;"><span>        Py_ssize_t tail;
</span></span><span style="display:flex;"><span>        tail = (Py_SIZE(a) - ihigh) * <span style="color:#00f">sizeof</span>(PyObject *);
</span></span><span style="display:flex;"><span>        memmove(&amp;item[ihigh+d], &amp;item[ihigh], tail);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (list_resize(a, Py_SIZE(a) + d) &lt; 0) {
</span></span><span style="display:flex;"><span>            memmove(&amp;item[ihigh], &amp;item[ihigh+d], tail);
</span></span><span style="display:flex;"><span>            memcpy(&amp;item[ilow], recycle, s);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> Error;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        item = a-&gt;ob_item;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (d &gt; 0) { <span style="color:#008000">/* Insert d items */</span>
</span></span><span style="display:flex;"><span>        k = Py_SIZE(a);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (list_resize(a, k+d) &lt; 0)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> Error;
</span></span><span style="display:flex;"><span>        item = a-&gt;ob_item;
</span></span><span style="display:flex;"><span>        memmove(&amp;item[ihigh+d], &amp;item[ihigh],
</span></span><span style="display:flex;"><span>            (k - ihigh)*<span style="color:#00f">sizeof</span>(PyObject *));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (k = 0; k &lt; n; k++, ilow++) {
</span></span><span style="display:flex;"><span>        PyObject *w = vitem[k];
</span></span><span style="display:flex;"><span>        Py_XINCREF(w);
</span></span><span style="display:flex;"><span>        item[ilow] = w;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (k = norig - 1; k &gt;= 0; --k)
</span></span><span style="display:flex;"><span>        Py_XDECREF(recycle[k]);
</span></span><span style="display:flex;"><span>    result = 0;
</span></span><span style="display:flex;"><span> Error:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (recycle != recycle_on_stack)
</span></span><span style="display:flex;"><span>        PyMem_Free(recycle);
</span></span><span style="display:flex;"><span>    Py_XDECREF(v_as_SF);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span><span style="color:#00f">#undef b
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>}
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># shrinking list by deleting elements</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = [1]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.append(2)
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>120
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.pop(len(l)-1)
</span></span><span style="display:flex;"><span>2
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># comparing with creating new one</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = l[:len(l)]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>64
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span></code></pre></div><hr>
<p><strong>shrinking list by created new  one:</strong></p>
<ol>
<li><code>list_preallocate_exact</code> call by <code>[].extend()</code> or <code>l += l1</code></li>
<li><code>list_new_prealloc</code> call by creating new ones, like <code>l = [1,2,3]</code> or <code>l = [1,2] + [3]</code></li>
<li><code>list_new_prealloc</code> and <code>list_preallocate_exact</code> only allocated difference size when the length of list is <strong>odd</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#008000">// Python-3.10.6/Objects/listobject.c
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#2b91af">int</span>
</span></span><span style="display:flex;"><span>list_preallocate_exact(PyListObject *self, Py_ssize_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    assert(self-&gt;ob_item == NULL);
</span></span><span style="display:flex;"><span>    assert(size &gt; 0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">/* Since the Python memory allocator has granularity of 16 bytes on 64-bit
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * platforms (8 on 32-bit), there is no benefit of allocating space for
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * the odd number of items, and there is no drawback of rounding the
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     * allocated size up to the nearest even number.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">     */</span>
</span></span><span style="display:flex;"><span>    size = (size + 1) &amp; ~(size_t)1;
</span></span><span style="display:flex;"><span>    PyObject **items = PyMem_New(PyObject*, size);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (items == NULL) {
</span></span><span style="display:flex;"><span>        PyErr_NoMemory();
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> -1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    self-&gt;ob_item = items;
</span></span><span style="display:flex;"><span>    self-&gt;allocated = size;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#008000">// Python-3.10.6/Objects/listobject.c
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> PyObject *
</span></span><span style="display:flex;"><span>list_new_prealloc(Py_ssize_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    assert(size &gt; 0);
</span></span><span style="display:flex;"><span>    PyListObject *op = (PyListObject *) PyList_New(0);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (op == NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    assert(op-&gt;ob_item == NULL);
</span></span><span style="display:flex;"><span>    op-&gt;ob_item = PyMem_New(PyObject *, size);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (op-&gt;ob_item == NULL) {
</span></span><span style="display:flex;"><span>        Py_DECREF(op);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> PyErr_NoMemory();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    op-&gt;allocated = size;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> (PyObject *) op;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p><strong>Test: Python List Resize</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># list_preallocate_exact</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = []
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.extend([1,2,3])
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>72
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = l[:len(l)]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>64
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>80
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># list_new_prealloc</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = [1,2,3]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>72
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = l[:len(l)]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>80
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; 
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; 
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># only diff when the length of list is odd</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; 
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># list_preallocate_exact</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = []
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.extend([1,2,3,4,5,6])
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>104
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = l[:len(l)]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>104
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; <span style="color:#008000"># list_new_prealloc</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = [1,2,3,4,5,6]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>104
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l = l[:len(l)]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; sys.getsizeof(l)
</span></span><span style="display:flex;"><span>104
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; l.__sizeof__()
</span></span><span style="display:flex;"><span>88
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span></code></pre></div><hr>
<p><strong>Simulation: How List Delete Element:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>nums = [1,2,3,4,5,6]
</span></span><span style="display:flex;"><span>i = 0
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> j <span style="color:#00f">in</span> range(len(nums)): <span style="color:#008000"># all of done by memmove</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> nums[j] != 4:
</span></span><span style="display:flex;"><span>        nums[i] = nums[j]
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    nums = nums[:i]
</span></span></code></pre></div><h2 id="real-world-python">Real World Python</h2>
<h3 id="common-bug-in-range-delete-element">Common Bug in Range Delete Element</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#008000"># P. IndexError: list index out of range</span>
</span></span><span style="display:flex;"><span>nums = [1,2,3,4,5,6]
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(len(nums)):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> nums[i] == 9:
</span></span><span style="display:flex;"><span>        nums.pop(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># P. skip check some element</span>
</span></span><span style="display:flex;"><span>nums = [1,2,3,4,4,5,6]
</span></span><span style="display:flex;"><span><span style="color:#008000"># output: [1,2,3,4,5,6]</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> v <span style="color:#00f">in</span> nums:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> v == 4:
</span></span><span style="display:flex;"><span>        nums.remove(v)
</span></span></code></pre></div><h3 id="remove-element-in-range-safely">Remove Element in Range Safely</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#008000"># remove element in range safely</span>
</span></span><span style="display:flex;"><span>nums = [1,2,3,4,5,6]
</span></span><span style="display:flex;"><span>i = 0
</span></span><span style="display:flex;"><span><span style="color:#00f">while</span> i &lt; len(nums):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> nums[i] == 4:
</span></span><span style="display:flex;"><span>        nums.pop(i)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>:
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># best way to remove element in range</span>
</span></span><span style="display:flex;"><span>nums = [1,2,3,4,5,6]
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(len(nums) - 1, -1, -1):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> nums[i] == 4:
</span></span><span style="display:flex;"><span>        nums.pop(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># P. too many Load / Store ops cause bad performance (&gt; 0.5x slower)</span>
</span></span><span style="display:flex;"><span>nums = [1,2,3,4,5,6]
</span></span><span style="display:flex;"><span>i = 0
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> j <span style="color:#00f">in</span> range(len(nums)):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> nums[j] != 4:
</span></span><span style="display:flex;"><span>        nums[i] = nums[j]
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># result is nums[:i]</span>
</span></span></code></pre></div><h2 id="faq">FAQ</h2>
<p>Q: Difference between <strong><code>list.clear()</code></strong>  and <strong><code>l = []</code></strong> <br>
A: Two of them are free memory by setting item as <strong>empty list []</strong>, but <strong><code>list.clear()</code></strong> will looping and free all PyObjects, and memory will be relased immedialy (when function call), <strong><code>l = []</code></strong>  is making ListObject unreachable and let it recycle by GC in background.</p>
<hr>
<p>Q: Difference between <strong>listobject (list type)</strong> and <strong>arraymodule (array type)</strong> ?<br>
A: Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained. Also, they use different resize algorithm, and <strong>ArrayModule</strong> require less memory than <strong>ListObject</strong> when has same number of objects.</p>
<h2 id="references">References</h2>
<ol>
<li><a href="https://docs.python.org/3.8/library/dis.html">dis - Disassembler for Python bytecode</a></li>
<li><a href="https://docs.python.org/3/library/sys.html?highlight=getsizeof#sys.getsizeof">python - sys.getsizeof()</a></li>
<li><a href="https://wiki.python.org/moin/TimeComplexity">python - TimeComplexity</a></li>
<li><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">python - PerformanceTips</a></li>
<li><a href="https://linux.die.net/man/3/realloc">linux - realloc</a></li>
<li><a href="https://linux.die.net/man/3/memmove">linux - memmove</a></li>
<li><a href="https://github.com/nasrat-v/asm_minilibc/blob/master/memmove.s#L6">minilibc - the asm simulation of memmove</a></li>
<li><a href="https://docs.python.org/3/library/array.html">python3 - array</a></li>
</ol>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/python">python</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2022  © Copyright chaosmatrix |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
