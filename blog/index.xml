<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Chaosmatrix</title>
    <link>https://chaosmatrix.github.io/blog/</link>
    <description>Recent content in Blogs on Chaosmatrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© Copyright chaosmatrix</copyright>
    <lastBuildDate>Sat, 20 Aug 2022 21:05:18 +0800</lastBuildDate><atom:link href="https://chaosmatrix.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HTTP Serving Compressed File</title>
      <link>https://chaosmatrix.github.io/blog/http_serving_compressed_file/</link>
      <pubDate>Sat, 20 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/http_serving_compressed_file/</guid>
      <description>Abstract Most web browsers include built-in support for gzip, deflate, br Most programming languages include built-in support for gzip and deflate, and br typically has community support Nginx - ngx_http_gzip_static_module Conclusions:
Check config: if gzip_static enable or not ? Check request header: client support gzip or not ? when using common algorithm, like &amp;ldquo;gzip&amp;rdquo;, skiping this seems no problem Mapping url to file path with given rule (filename extension is &amp;ldquo;.</description>
    </item>
    
    <item>
      <title>DNS Should I Use DNSSEC</title>
      <link>https://chaosmatrix.github.io/blog/dns_should_i_use_dnssec/</link>
      <pubDate>Mon, 08 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/dns_should_i_use_dnssec/</guid>
      <description>Abstract WARNING DNSSEC can only works as expected when the resolver ensure the zone and the upstream nameserver support DNSSEC WARNING less 50% top-1m website/domain enable DNSSEC, most zone owned by google/amazon/microsoft &amp;hellip; not support DNSSEC DNSSEC can only make sure the data that the resolver fetching is provided by the zone&amp;rsquo;s owner (require resolver verify the signature) DNSSEC can detect (not prevent) dns hijacking only when resolver/client verify the signature As Owner/Server: Assess only use it when you pretty sure you need it, and can&amp;rsquo;t replace with another way, and should base on the report that the use of DNSSEC validation for your customer&amp;rsquo;s ISPs public resolvers use E2EE protocol to protect the communication between client and server instead of ensuring client get the right server&amp;rsquo;s address try to use DNS-Over-HTTPS/DNS-Over-QUIC to prevent dns hijacking if you can control how client resolve domain, for example desktop/mobile app As Resolver: Recommend But Not Forcing Recursive Resolver: Recommend, try to add additional security check, like credit score of ip address to detect dns hijacking Forward Resolver: Not Recommend, try to communicate with upstream nameserver with E2EE protocol, use DNSSEC only for the zone that pretty sure has full DNSSEC support and sensitive zone (like bank, shop) Basic DNSSEC strengthens authentication in DNS using digital signatures based on public key cryptography.</description>
    </item>
    
    <item>
      <title>UDP Server Listen On 0.0.0.0</title>
      <link>https://chaosmatrix.github.io/blog/udp_server_listen_on_0.0.0.0/</link>
      <pubDate>Mon, 01 Aug 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/udp_server_listen_on_0.0.0.0/</guid>
      <description>Basic UDP is connectionless protocol, it won&amp;rsquo;t create new socket for any incoming datagrams, so, function like LocalAddr() will return incorrect destination address that associated with incoming datagrams, and response datagram will be routed base on system&amp;rsquo;s default routing rule, which might not match client&amp;rsquo;s 5-tuple.
Example:
# basic 1. server: * has two address: 10.1.2.2(primary) and 10.1.2.3(secondary) * default route is 10.1.2.2 (default outgoing address) 2. client: * has one address: 10.</description>
    </item>
    
    <item>
      <title>Think Least_Conn In Math</title>
      <link>https://chaosmatrix.github.io/blog/think_least_conn_in_math/</link>
      <pubDate>Fri, 29 Jul 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/think_least_conn_in_math/</guid>
      <description>Basic least_conn is a load balance algorithm, which distributed incoming request to the server with least connected connections.
Think in math distribute requests to n server, least_conn try to archive a goal every server as busy as others.
total time d that n servers finished requests:
$$\begin{align*} &amp; d = \sum_{i=1}^nd_i = n * d_{avg} \\ \\ &amp; {d_i}\text{ : duration of } i^{th} \text{ server to finish the distributed requests} \\ &amp; {d_{avg}}\text{ : avg duration that a server finished distribted requests} \\ \end{align*}$$ what least_conn algorithm want to archive is :</description>
    </item>
    
    <item>
      <title>Lock-Free Update Data</title>
      <link>https://chaosmatrix.github.io/blog/lock_free_update_data/</link>
      <pubDate>Thu, 28 Jul 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/lock_free_update_data/</guid>
      <description>Rule:
update pointer, rather than update pointer&amp;rsquo;s data an object with zero reference (unreachable object), will be recycle by GC var rcuCfg *RcuCfg type RcuCfg struct { cfg *Cfg lock sync.Mutex // even don&amp;#39;t need } func newCfgFromOld(old *Cfg) { cfg := &amp;amp;Cfg{} DeepCopy(cfg, old) return cfg } func rcuRead() *Cfg { return rcuCfg.cfg } func rcuUpdate() { rcuCfg.lock.Lock() defer rcuCfg.lock.Unlock() cfg := newCfgFromOld(rcuCfg.cfg) rcuCfg.cfg = cfg } reference:
what is RCU </description>
    </item>
    
    <item>
      <title>Detect Half Closed Connection</title>
      <link>https://chaosmatrix.github.io/blog/detect_half_closed_connection/</link>
      <pubDate>Wed, 27 Jul 2022 21:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/detect_half_closed_connection/</guid>
      <description>$common$ read 1-byte with deadline depend on program language or platform implementation, some use read 0-byte
WARNING: you should only use this way when you ensure there&#39;s no unread value data
// Golang, read 0-byte, always return nil // https://github.com/golang/go/issues/10940#issuecomment-245773886 func checkConn(conn net.Conn, timeout time.Duration) error { buf := make([]byte, 1) err := conn.SetReadDeadline(time.Now().Add(timeout)) if err != nil { return err } n, err := conn.Read(buf) if err == io.EOF { return err } if n !</description>
    </item>
    
    <item>
      <title>Transaction Ops</title>
      <link>https://chaosmatrix.github.io/blog/transaction-ops/</link>
      <pubDate>Tue, 17 Dec 2019 20:05:18 +0800</pubDate>
      
      <guid>https://chaosmatrix.github.io/blog/transaction-ops/</guid>
      <description>Rules Every Operation must has RollBack Operation All ops done success or no ops done Transaction Ops Rule Stages Backup Stage backup current system state GoTo Next if Success Exit if it fails PreTest Stage in order to generate test rule make sure system working before apply operation GoTo Next if Success Exit if it fails Operate Stage do the operation that we want to do GoTo Next if Success GoTo RollBack Stage if it fails PostTest Stage apply custom-built test rule apply test rule generate in PreTest Stage GoTo RollBack Stage if it fails RollBack Stage only exec while Failed PostTest Stage apply Backup Stage to rollback system Use Transaction Ops Framework Example Update Network Route #!</description>
    </item>
    
  </channel>
</rss>
